<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Noet WASM Test Runner</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }

        h1 {
            color: #333;
            border-bottom: 2px solid #4CAF50;
            padding-bottom: 10px;
        }

        .test-section {
            background: white;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .test-result {
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
        }

        .test-result.pass {
            background: #e8f5e9;
            border-left: 4px solid #4CAF50;
        }

        .test-result.fail {
            background: #ffebee;
            border-left: 4px solid #f44336;
        }

        .test-result.info {
            background: #e3f2fd;
            border-left: 4px solid #2196F3;
        }

        .summary {
            font-size: 18px;
            font-weight: bold;
            padding: 15px;
            border-radius: 4px;
            margin-top: 20px;
        }

        .summary.success {
            background: #4CAF50;
            color: white;
        }

        .summary.failure {
            background: #f44336;
            color: white;
        }

        pre {
            background: #f5f5f5;
            padding: 10px;
            border-radius: 4px;
            overflow-x: auto;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #2196F3;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <h1></h1>üß™ Noet WASM Test Runner</h1>

    <div id="loading" class="loading">
        <div class="spinner"></div>
        <p>Loading WASM module and beliefbase.json...</p>
    </div>

    <div id="results" style="display: none;"></div>

    <script type="module">
        // Test results container
        const results = document.getElementById('results');
        const loading = document.getElementById('loading');
        let testsPassed = 0;
        let testsFailed = 0;

        function log(message, type = 'info') {
            const div = document.createElement('div');
            div.className = `test-result ${type}`;
            div.textContent = message;
            results.appendChild(div);

            if (type === 'pass') testsPassed++;
            if (type === 'fail') testsFailed++;

            console.log(`[${type.toUpperCase()}] ${message}`);
        }

        function assert(condition, message) {
            if (condition) {
                log(`‚úÖ PASS: ${message}`, 'pass');
            } else {
                log(`‚ùå FAIL: ${message}`, 'fail');
                throw new Error(`Assertion failed: ${message}`);
            }
        }

        function assertEqual(actual, expected, message) {
            if (actual === expected) {
                log(`‚úÖ PASS: ${message} (got ${actual})`, 'pass');
            } else {
                log(`‚ùå FAIL: ${message} (expected ${expected}, got ${actual})`, 'fail');
                throw new Error(`Assertion failed: ${message}`);
            }
        }

        function createSection(title) {
            const section = document.createElement('div');
            section.className = 'test-section';
            const heading = document.createElement('h2');
            heading.textContent = title;
            section.appendChild(heading);
            results.appendChild(section);
            return section;
        }

        async function runTests() {
            try {
                // Hide loading, show results
                loading.style.display = 'none';
                results.style.display = 'block';

                log('Starting WASM tests...', 'info');

                // Import WASM module
                log('Importing WASM module from ../../pkg/noet_core.js', 'info');
                const { default: init, BeliefBaseWasm } = await import('../../pkg/noet_core.js');

                // Initialize WASM
                log('Initializing WASM...', 'info');
                await init();
                log('‚úÖ WASM initialized successfully', 'pass');

                // Load beliefbase.json
                log('Fetching index.html to extract entry point metadata...', 'info');
                const indexResponse = await fetch('./test-output/index.html');
                assert(indexResponse.ok, 'index.html exists and is accessible');

                const indexHtml = await indexResponse.text();
                const parser = new DOMParser();
                const indexDoc = parser.parseFromString(indexHtml, 'text/html');
                const metadataScript = indexDoc.getElementById('noet-metadata');
                assert(metadataScript, 'Metadata script tag found in index.html');

                const metadataJson = metadataScript.textContent;
                const documentMetadata = JSON.parse(metadataJson);
                assert(documentMetadata.bid, 'Entry point BID found in metadata');
                log(`Entry point BID: ${documentMetadata.bid}`, 'info');

                log('Fetching beliefbase.json...', 'info');
                const response = await fetch('./test-output/beliefbase.json');
                assert(response.ok, 'beliefbase.json exists and is accessible');

                const json = await response.text();
                log(`Loaded ${(json.length / 1024).toFixed(2)} KB of JSON data`, 'info');

                // Create BeliefBase from JSON
                log('Creating BeliefBaseWasm from JSON...', 'info');
                const bb = new BeliefBaseWasm(json, metadataJson);
                log('‚úÖ BeliefBaseWasm created successfully', 'pass');

                // Test 1: Node count
                createSection('Test 1: Basic Queries');
                const nodeCount = bb.node_count();
                assert(nodeCount > 0, `Node count is positive (${nodeCount} nodes)`);
                log(`Loaded ${nodeCount} nodes total`, 'info');

                // Test 2: Get documents
                createSection('Test 2: Document Queries');
                const documents = bb.get_documents();
                assert(Array.isArray(documents), 'get_documents() returns array');
                assert(documents.length > 0, `Found ${documents.length} documents`);
                log(`Documents: ${documents.map(d => d.title).join(', ')}`, 'info');

                // Test 3: Get networks
                createSection('Test 3: Network Queries');
                const networks = bb.get_networks();
                assert(Array.isArray(networks), 'get_networks() returns array');
                assert(networks.length > 0, `Found ${networks.length} networks`);
                log(`Networks: ${networks.map(n => n.title).join(', ')}`, 'info');

                // Test 4: Get node by BID
                createSection('Test 4: Node Retrieval');
                if (documents.length > 0) {
                    const firstDoc = documents[0];
                    log(`Testing get_by_bid() with document: ${firstDoc.title}`, 'info');

                    const retrieved = bb.get_by_bid(firstDoc.bid);
                    assert(retrieved !== null, 'Retrieved node is not null');
                    assertEqual(retrieved.bid, firstDoc.bid, 'Retrieved node has correct BID');
                    assertEqual(retrieved.title, firstDoc.title, 'Retrieved node has correct title');
                }

                // Test 5: Search
                createSection('Test 5: Search Functionality');
                const searchResults = bb.search('test');
                assert(Array.isArray(searchResults), 'search() returns array');
                log(`Search for "test" returned ${searchResults.length} results`, 'info');

                // Test 6: Backlinks
                createSection('Test 6: Backlinks');
                if (documents.length > 0) {
                    const doc = documents[0];
                    const backlinks = bb.get_backlinks(doc.bid);
                    assert(Array.isArray(backlinks), 'get_backlinks() returns array');
                    log(`Document "${doc.title}" has ${backlinks.length} backlinks`, 'info');
                }

                // Test 7: Forward links
                createSection('Test 7: Forward Links');
                if (documents.length > 0) {
                    const doc = documents[0];
                    const forwardLinks = bb.get_forward_links(doc.bid);
                    assert(Array.isArray(forwardLinks), 'get_forward_links() returns array');
                    log(`Document "${doc.title}" has ${forwardLinks.length} forward links`, 'info');
                }

                // Test 8: Invalid BID handling
                createSection('Test 8: Error Handling');
                const invalidNode = bb.get_by_bid('invalid-bid-format');
                assertEqual(invalidNode, null, 'Invalid BID returns null');

                const invalidBacklinks = bb.get_backlinks('invalid-bid');
                assert(Array.isArray(invalidBacklinks), 'Invalid BID backlinks returns empty array');
                assertEqual(invalidBacklinks.length, 0, 'Invalid BID backlinks array is empty');

                // Test 9: Namespace functions
                createSection('Test 9: System Namespaces');
                const hrefNs = BeliefBaseWasm.href_namespace();
                assert(typeof hrefNs === 'string', 'href_namespace() returns string');
                assert(hrefNs.length > 0, 'href_namespace() returns non-empty string');
                log(`Href namespace: ${hrefNs}`, 'info');

                const assetNs = BeliefBaseWasm.asset_namespace();
                assert(typeof assetNs === 'string', 'asset_namespace() returns string');
                assert(assetNs.length > 0, 'asset_namespace() returns non-empty string');
                log(`Asset namespace: ${assetNs}`, 'info');

                const apiNs = BeliefBaseWasm.buildonomy_namespace();
                assert(typeof apiNs === 'string', 'buildonomy_namespace() returns string');
                assert(apiNs.length > 0, 'buildonomy_namespace() returns non-empty string');
                log(`API namespace: ${apiNs}`, 'info');

                // Test 10: NodeContext
                createSection('Test 10: NodeContext');
                if (documents.length > 0) {
                    const doc = documents[0];
                    log(`Getting context for document: ${doc.title}`, 'info');

                    const ctx = bb.get_context(doc.bid);
                    assert(ctx !== null, 'get_context() returns non-null value');
                    assert(ctx.node !== undefined, 'NodeContext has node field');
                    assertEqual(ctx.node.bid, doc.bid, 'NodeContext.node has correct BID');

                    assert(typeof ctx.root_path === 'string', 'NodeContext has root_path string');
                    log(`Root path: ${ctx.root_path}`, 'info');

                    assert(typeof ctx.home_net === 'string', 'NodeContext has home_net string');
                    log(`Home network: ${ctx.home_net}`, 'info');

                    assert(typeof ctx.related_nodes === 'object', 'NodeContext.related_nodes is object');
                    assert(!Array.isArray(ctx.related_nodes), 'NodeContext.related_nodes is not array (it is a map)');
                    const relatedCount = Object.keys(ctx.related_nodes).length;
                    log(`Related nodes: ${relatedCount}`, 'info');

                    // Verify we can lookup nodes by BID
                    if (relatedCount > 0) {
                        const firstBid = Object.keys(ctx.related_nodes)[0];
                        const relatedNode = ctx.related_nodes[firstBid];
                        assert(relatedNode !== undefined, 'Can lookup related node by BID');
                        assert(relatedNode.bid === firstBid, 'Related node has correct BID');
                        log(`  Sample related node: ${relatedNode.title || relatedNode.bid}`, 'info');
                    }

                    assert(ctx.graph !== undefined, 'NodeContext has graph field');
                    assert(typeof ctx.graph === 'object', 'NodeContext.graph is object');
                    log(`Graph contains ${Object.keys(ctx.graph).length} weight kinds`, 'info');

                    // Check graph structure (HashMap<WeightKind, (Vec<Bid>, Vec<Bid>)>)
                    for (const [weightKind, [sources, sinks]] of Object.entries(ctx.graph)) {
                        assert(Array.isArray(sources), `Graph[${weightKind}].sources is array`);
                        assert(Array.isArray(sinks), `Graph[${weightKind}].sinks is array`);
                        log(`  ${weightKind}: ${sources.length} sources, ${sinks.length} sinks`, 'info');
                    }
                }

                // Test 11: get_paths() - Navigation tree data
                log('Test 11: get_paths() - Navigation tree data', 'info');
                {
                    const paths = bb.get_paths();
                    assert(paths !== null && paths !== undefined, 'get_paths() returns data');
                    assert(paths instanceof Map, 'get_paths() returns Map');

                    const networkBids = Array.from(paths.keys());
                    assert(networkBids.length > 0, 'At least one network in paths');
                    log(`Found ${networkBids.length} networks`, 'info');

                    // Check structure: network_bid ‚Üí Vec<(path, bid, order_indices)>
                    for (const netBid of networkBids) {
                        const pathData = paths.get(netBid);
                        assert(Array.isArray(pathData), `Network ${netBid} has array of paths`);
                        log(`  Network ${netBid}: ${pathData.length} paths`, 'info');

                        // Check first path entry structure
                        if (pathData.length > 0) {
                            const [path, bid, order] = pathData[0];
                            assert(typeof path === 'string', 'Path is string');
                            assert(typeof bid === 'string', 'BID is string');
                            assert(Array.isArray(order), 'Order indices is array');
                            log(`    Example: "${path}" ‚Üí ${bid} [${order.join(', ')}]`, 'info');
                        }
                    }

                    // Log statistics
                    const totalPaths = Array.from(paths.values()).reduce((sum, pathArr) => sum + pathArr.length, 0);
                    log(`Total paths across all networks: ${totalPaths}`, 'info');
                }

                // Test 12: get_nav_tree() - Flat map with parent/child BIDs
                log('Test 12: get_nav_tree() - Flat map with parent/child BIDs', 'info');
                {
                    const tree = bb.get_nav_tree();
                    console.log('DEBUG: tree =', tree);
                    console.log('DEBUG: typeof tree =', typeof tree);
                    console.log('DEBUG: tree.nodes =', tree.nodes);
                    console.log('DEBUG: tree.roots =', tree.roots);
                    assert(tree !== null && tree !== undefined, 'get_nav_tree() returns data');
                    assert(typeof tree === 'object', 'get_nav_tree() returns object');
                    assert(tree.nodes !== undefined, 'NavTree has nodes field');

                    // IMPORTANT: tree.nodes is a JavaScript Map, not a plain object
                    const nodesIsMap = tree.nodes instanceof Map;
                    assert(nodesIsMap, 'NavTree.nodes is a Map (not plain object)');
                    log('‚úì NavTree.nodes is a Map', 'pass');

                    assert(tree.roots !== undefined, 'NavTree has roots field');
                    assert(Array.isArray(tree.roots), 'NavTree.roots is array');
                    assert(tree.roots.length > 0, 'At least one root node (network) in tree');
                    log(`Found ${tree.roots.length} networks`, 'info');

                    // Validate flat map structure - use Map methods
                    const nodeBids = Array.from(tree.nodes.keys());
                    assert(nodeBids.length > 0, 'Nodes map is not empty');
                    assert(tree.nodes.size > 0, 'Map.size is greater than 0');
                    log(`Total nodes in map: ${nodeBids.length} (Map.size = ${tree.nodes.size})`, 'info');

                    // Validate each node in the map - use Map.get()
                    for (const bid of nodeBids) {
                        const node = tree.nodes.get(bid);
                        assert(typeof node.bid === 'string', 'NavNode has bid');
                        assert(node.bid === bid, 'NavNode bid matches map key');
                        assert(typeof node.title === 'string', 'NavNode has title');
                        assert(typeof node.path === 'string', 'NavNode has path');
                        assert(Array.isArray(node.children), 'NavNode has children array (of BIDs)');
                        assert(node.parent === null || node.parent === undefined || typeof node.parent === 'string', 'NavNode parent is null, undefined, or string');

                        // Verify path normalization (non-root nodes should have .html extension if they have a real path)
                        // Note: Some nodes may have BID as path (sections without files) or empty path (networks)
                        if (node.path && node.path.length > 0) {
                            // Skip validation if path looks like a BID (UUID format with hyphens)
                            const looksLikeBid = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/.test(node.path);

                            if (!looksLikeBid) {
                                const hasHtmlExt = node.path.endsWith('.html') || node.path.includes('.html#');
                                assert(hasHtmlExt,
                                    `NavNode path should use .html extension (got: ${node.path})`);
                            }
                        }

                        // Verify titles are real (not path-based heuristics)
                        if (node.parent) { // Has parent = not a network node
                            assert(!node.title.includes('/'), 'Node title should not contain path separators');
                            assert(!node.title.endsWith('.md'), 'Node title should not end with .md');
                            assert(!node.title.endsWith('.html'), 'Node title should not end with .html');
                        }

                        // Verify parent references are valid
                        if (node.parent) {
                            const parentExists = tree.nodes.has(node.parent);
                            assert(parentExists, `Parent ${node.parent} exists in map`);
                        }

                        // Verify child references are valid
                        for (const childBid of node.children) {
                            const childExists = tree.nodes.has(childBid);
                            assert(childExists, `Child ${childBid} exists in map`);
                        }
                    }

                    // Test rendering the navigation tree HTML (using Map.get())
                    log('Testing HTML rendering with Map...', 'info');
                    {
                        if (tree.roots && tree.roots.length > 0) {
                            let testHtml = '<ul class="noet-nav-tree">';
                            let nodeCount = 0;

                            for (const rootBid of tree.roots) {
                                const rootNode = tree.nodes.get(rootBid);
                                if (rootNode) {
                                    nodeCount++;
                                    testHtml += `<li>${rootNode.title} (${rootNode.children.length} children)</li>`;
                                } else {
                                    log(`WARNING: Root node ${rootBid} not found in Map!`, 'fail');
                                }
                            }
                            testHtml += '</ul>';

                            log(`Rendered ${nodeCount} root nodes`, nodeCount > 0 ? 'pass' : 'fail');
                            if (testHtml.length > 50) {
                                log(`Sample HTML: ${testHtml.substring(0, 200)}...`, 'info');
                            }

                            // Check if any nodes have empty titles
                            let emptyTitleCount = 0;
                            for (const bid of nodeBids) {
                                const node = tree.nodes.get(bid);
                                if (!node.title || node.title.trim() === '') {
                                    emptyTitleCount++;
                                    console.warn('Node with empty title:', bid, node);
                                }
                            }
                            if (emptyTitleCount > 0) {
                                log(`WARNING: ${emptyTitleCount} nodes have empty titles`, 'fail');
                            } else {
                                log('‚úì All nodes have non-empty titles', 'pass');
                            }
                        } else {
                            log('ERROR: No roots to render', 'fail');
                        }
                    }

                    // Test parent chain traversal for a non-root node
                    const nonRootNodes = nodeBids.filter(bid => {
                        const node = tree.nodes.get(bid);
                        return node.parent !== null && node.parent !== undefined;
                    });
                    if (nonRootNodes.length > 0) {
                        const testBid = nonRootNodes[0];
                        const parentChain = [];
                        let currentBid = testBid;

                        while (currentBid) {
                            parentChain.push(currentBid);
                            const node = nodesIsMap ? tree.nodes.get(currentBid) : tree.nodes[currentBid];
                            currentBid = node.parent;
                        }

                        const chainTitles = parentChain.map(bid => {
                            const node = nodesIsMap ? tree.nodes.get(bid) : tree.nodes[bid];
                            return node.title;
                        }).join(' > ');
                        log(`Parent chain example (${parentChain.length} levels): ${chainTitles}`, 'info');
                        assert(parentChain.length >= 2, 'Parent chain has at least node + network');
                    }

                    // Test cycle detection in parent chain
                    for (const bid of nodeBids) {
                        const visited = new Set();
                        let currentBid = bid;
                        const startNode = nodesIsMap ? tree.nodes.get(bid) : tree.nodes[bid];

                        while (currentBid) {
                            assert(!visited.has(currentBid), `No cycles in parent chain starting from ${startNode.title}`);
                            visited.add(currentBid);
                            const node = nodesIsMap ? tree.nodes.get(currentBid) : tree.nodes[currentBid];
                            currentBid = node.parent;
                        }
                    }

                    log('All titles properly extracted from BeliefNode state', 'info');
                    log('Flat map structure validated (O(1) lookup, parent chain traversal)', 'info');
                    log('No cycles detected in parent chains', 'info');
                }

                // === Test Path Manipulation Functions ===
                createSection('Path Manipulation Functions');
                {
                    log('Testing normalizePath...', 'info');

                    // Basic normalization
                    assertEqual(
                        BeliefBaseWasm.normalizePath('dir/../file.html'),
                        'file.html',
                        'normalizePath resolves .. segments'
                    );

                    assertEqual(
                        BeliefBaseWasm.normalizePath('dir/./file.html'),
                        'dir/file.html',
                        'normalizePath resolves . segments'
                    );

                    assertEqual(
                        BeliefBaseWasm.normalizePath('dir1/dir2/../file.html'),
                        'dir1/file.html',
                        'normalizePath resolves nested .. segments'
                    );

                    assertEqual(
                        BeliefBaseWasm.normalizePath('/net1_dir1/hsml.html'),
                        '/net1_dir1/hsml.html',
                        'normalizePath preserves leading slash (normalizes structure)'
                    );

                    log('Testing pathParts...', 'info');

                    // pathParts separates path, filename, and anchor
                    const parts1 = BeliefBaseWasm.pathParts('net1_dir1/hsml.html#section');
                    assertEqual(parts1.path, 'net1_dir1', 'pathParts extracts directory');
                    assertEqual(parts1.filename, 'hsml.html', 'pathParts extracts filename');
                    assertEqual(parts1.anchor, 'section', 'pathParts extracts anchor (without # prefix)');

                    const parts2 = BeliefBaseWasm.pathParts('net1_dir1/hsml.html');
                    assertEqual(parts2.path, 'net1_dir1', 'pathParts returns directory for document');
                    assertEqual(parts2.filename, 'hsml.html', 'pathParts returns filename');
                    assertEqual(parts2.anchor, '', 'pathParts returns empty anchor when none');

                    const parts3 = BeliefBaseWasm.pathParts('net1_dir1/subdir/file.html');
                    assertEqual(parts3.path, 'net1_dir1/subdir', 'pathParts returns directory for nested file');
                    assertEqual(parts3.filename, 'file.html', 'pathParts returns filename for nested file');

                    log('Testing pathParent...', 'info');

                    // pathParent strips anchor from document (returns document path)
                    assertEqual(
                        BeliefBaseWasm.pathParent('net1_dir1/hsml.html#section'),
                        'net1_dir1/hsml.html',
                        'pathParent strips anchor from document'
                    );

                    // pathParent returns directory for document
                    assertEqual(
                        BeliefBaseWasm.pathParent('net1_dir1/hsml.html'),
                        'net1_dir1',
                        'pathParent returns directory for document'
                    );

                    // pathParent returns parent directory for directory path
                    assertEqual(
                        BeliefBaseWasm.pathParent('net1_dir1/subdir'),
                        'net1_dir1',
                        'pathParent returns parent directory for directory path'
                    );

                    // To get directory from path with anchor, call pathParent twice
                    const withoutAnchor = BeliefBaseWasm.pathParent('net1_dir1/hsml.html#section');
                    const directory = BeliefBaseWasm.pathParent(withoutAnchor);
                    assertEqual(
                        directory,
                        'net1_dir1',
                        'pathParent called twice gets directory from anchored path'
                    );

                    log('Testing pathJoin...', 'info');

                    // Join directory with relative file
                    assertEqual(
                        BeliefBaseWasm.pathJoin('net1_dir1', 'hstp.html', false),
                        'net1_dir1/hstp.html',
                        'pathJoin combines directory and file'
                    );

                    // Join directory path (no extension) with relative file (normalizes ..)
                    assertEqual(
                        BeliefBaseWasm.pathJoin('net1_dir1/subdir', '../file.html', false),
                        'net1_dir1/file.html',
                        'pathJoin normalizes .. in paths'
                    );

                    // Join document path (has extension) with relative file (normalizes ..)
                    assertEqual(
                        BeliefBaseWasm.pathJoin('net1_dir1/doc.html', '../other.html', false),
                        'other.html',
                        'pathJoin strips document and normalizes ..'
                    );

                    // Normalize resolves .. after join
                    assertEqual(
                        BeliefBaseWasm.normalizePath('net1_dir1/subdir/../file.html'),
                        'net1_dir1/file.html',
                        'normalizePath resolves .. after join'
                    );

                    // Join with anchor
                    assertEqual(
                        BeliefBaseWasm.pathJoin('net1_dir1/doc.html', 'section', true),
                        'net1_dir1/doc.html#section',
                        'pathJoin adds anchor with # separator'
                    );

                    log('Testing pathExtension...', 'info');

                    // Extract extension
                    assertEqual(
                        BeliefBaseWasm.pathExtension('file.html'),
                        'html',
                        'pathExtension extracts extension'
                    );

                    // Extract extension with anchor
                    assertEqual(
                        BeliefBaseWasm.pathExtension('file.html#section'),
                        'html',
                        'pathExtension ignores anchor'
                    );

                    // No extension
                    assertEqual(
                        BeliefBaseWasm.pathExtension('directory'),
                        '',
                        'pathExtension returns empty for no extension'
                    );

                    log('Testing real-world scenario: hsml.html -> hstp.html', 'info');

                    // Simulate clicking link in net1_dir1/hsml.html with href="hstp.html"
                    const currentPath = 'net1_dir1/hsml.html';
                    const relativeHref = 'hstp.html';

                    // pathParts on doc returns directory
                    const parts = BeliefBaseWasm.pathParts(currentPath);
                    const parentDir = parts.path;
                    assertEqual(
                        parentDir,
                        'net1_dir1',
                        'pathParts.path strips document from path'
                    );

                    // pathJoin combines directory + relative file
                    const resolvedPath = BeliefBaseWasm.pathJoin(parentDir, relativeHref, false);
                    assertEqual(
                        resolvedPath,
                        'net1_dir1/hstp.html',
                        'pathJoin creates full path to sibling document'
                    );

                    log('Testing complete relative path resolution with ..', 'info');

                    // Simulate ../../other.html from net1_dir1/subdir/doc.html
                    const deepPath = 'net1_dir1/subdir/doc.html';
                    const upTwoLevels = '../../other.html';

                    // pathParts strips doc.html -> net1_dir1/subdir
                    const deepParts = BeliefBaseWasm.pathParts(deepPath);
                    const deepParent = deepParts.path;
                    assertEqual(
                        deepParent,
                        'net1_dir1/subdir',
                        'pathParts.path of doc.html returns directory'
                    );

                    // pathJoin normalizes the path (resolves ..)
                    const joined = BeliefBaseWasm.pathJoin(deepParent, upTwoLevels, false);
                    assertEqual(
                        joined,
                        'other.html',
                        'pathJoin normalizes ../../ from subdir'
                    );

                    // Verify normalizePath also works independently
                    const normalized = BeliefBaseWasm.normalizePath('net1_dir1/subdir/../../other.html');
                    assertEqual(
                        normalized,
                        'other.html',
                        'normalizePath independently resolves complex .. sequences'
                    );

                    log('‚úì Path manipulation functions work correctly', 'pass');
                }


                // Summary
                const summary = document.createElement('div');
                summary.className = `summary ${testsFailed === 0 ? 'success' : 'failure'}`;
                summary.textContent = `Test Results: ${testsPassed} passed, ${testsFailed} failed`;
                results.appendChild(summary);

                if (testsFailed === 0) {
                    log('üéâ All tests passed!', 'pass');
                    console.log('%c‚úÖ ALL TESTS PASSED', 'color: green; font-size: 20px; font-weight: bold;');
                } else {
                    log(`‚ö†Ô∏è ${testsFailed} test(s) failed`, 'fail');
                    console.error(`‚ùå ${testsFailed} TESTS FAILED`);
                }

            } catch (error) {
                log(`üí• FATAL ERROR: ${error.message}`, 'fail');
                console.error('Test runner error:', error);

                const summary = document.createElement('div');
                summary.className = 'summary failure';
                summary.innerHTML = `
                    <strong>Test Runner Failed</strong><br>
                    ${error.message}<br>
                    <pre>${error.stack}</pre>
                `;
                results.appendChild(summary);
            }
        }

        // Run tests on page load
        runTests();
    </script>
</body>
</html>
