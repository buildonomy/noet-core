//! Asset management for HTML generation
//!
//! This module handles embedding and extracting UI assets (CSS, JavaScript, templates)
//! for the HTML viewer. Assets are always vendored (embedded in the binary) for:
//! - **Offline-first**: Works without internet connection
//! - **Reproducibility**: Same binary always produces same output
//! - **Security**: Users can verify exact asset versions
//! - **Simplicity**: No build-time configuration needed
//!
//! ## CDN Mode
//!
//! Users can optionally use CDN for Open Props via the `--cdn` CLI flag.
//! This reduces output directory size but requires internet connectivity.
//!
//! ## Usage
//!
//! ```rust,ignore
//! use noet_core::codec::assets;
//!
//! // Extract vendored assets to output directory
//! assets::extract_assets(output_dir, use_cdn)?;
//!
//! // Get appropriate stylesheet URLs
//! let urls = assets::get_stylesheet_urls(use_cdn);
//! ```

use crate::BuildonomyError;
use include_dir::{include_dir, Dir};
use std::path::Path;
use std::str::FromStr;

/// Embedded assets directory
///
/// All UI assets (CSS, JavaScript, templates) are embedded at compile time
/// using `include_dir!`. This creates a self-contained binary that works offline.
static ASSETS: Dir = include_dir!("$CARGO_MANIFEST_DIR/assets");

/// Embedded HTML templates
const TEMPLATE_SIMPLE: &str = include_str!("../../assets/template-simple.html");
const TEMPLATE_RESPONSIVE: &str = include_str!("../../assets/template-responsive.html");

/// Embedded WASM artifacts (generated by build.rs via wasm-pack)
/// These are compiled from src/wasm.rs and provide BeliefBaseWasm for browser use
/// Only included when bin feature is enabled (for CLI with HTML generation)
/// Note: WASM is compiled with --features wasm --no-default-features (different from main build)
#[cfg(feature = "bin")]
const WASM_JS_GLUE: &[u8] = include_bytes!("../../pkg/noet_core.js");
#[cfg(feature = "bin")]
const WASM_BINARY: &[u8] = include_bytes!("../../pkg/noet_core_bg.wasm");

/// Available HTML layout templates
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Layout {
    /// Simple layout: minimal article wrapper (backward compatible)
    Simple,
    /// Responsive SPA layout: full interactive interface with nav, metadata panel, graph area
    Responsive,
}

impl Layout {
    /// Get the template string for this layout
    pub fn template(&self) -> &'static str {
        match self {
            Layout::Simple => TEMPLATE_SIMPLE,
            Layout::Responsive => TEMPLATE_RESPONSIVE,
        }
    }

    /// Get the layout name as a string
    pub fn as_str(&self) -> &'static str {
        match self {
            Layout::Simple => "simple",
            Layout::Responsive => "responsive",
        }
    }
}

impl Default for Layout {
    fn default() -> Self {
        Layout::Simple
    }
}

impl FromStr for Layout {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "simple" => Ok(Layout::Simple),
            "responsive" => Ok(Layout::Responsive),
            unknown => Err(format!("Unknown layout: '{}'", unknown)),
        }
    }
}

impl std::fmt::Display for Layout {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.as_str())
    }
}

/// Stylesheet URLs for HTML generation
#[derive(Debug, Clone)]
pub struct StylesheetUrls {
    /// Open Props design tokens CSS
    pub open_props: String,
    /// Normalize CSS (from Open Props)
    pub normalize: String,
    /// Noet light theme CSS
    pub theme_light: String,
    /// Noet dark theme CSS
    pub theme_dark: String,
    /// Noet layout CSS (shared between themes)
    pub layout: String,
}

/// Extract vendored assets to output directory
///
/// This function extracts embedded UI assets to the specified output directory.
/// Assets are written to `output_dir/assets/`.
///
/// # Parameters
/// - `output_dir`: Base directory for HTML output
/// - `use_cdn`: If `true`, skip extracting Open Props (user wants CDN instead)
///
/// # Errors
/// - Returns error if directory creation fails
/// - Returns error if file extraction fails
///
/// # Examples
///
/// ```rust,ignore
/// // Extract all vendored assets (local Open Props)
/// assets::extract_assets(&output_path, false)?;
///
/// // Extract only custom CSS (use CDN for Open Props)
/// assets::extract_assets(&output_path, true)?;
/// ```
pub fn extract_assets(output_dir: &Path, use_cdn: bool) -> Result<(), BuildonomyError> {
    use std::fs;

    let assets_dest = output_dir.join("assets");
    fs::create_dir_all(&assets_dest)
        .map_err(|e| BuildonomyError::Io(format!("Failed to create assets directory: {e}")))?;

    if use_cdn {
        // Extract only our custom files, skip open-props/
        for entry in ASSETS.entries() {
            let path = entry.path();

            // Skip node_modules and open-props directory when using CDN
            if path.starts_with("node_modules") || path.starts_with("open-props") {
                continue;
            }

            let dest_path = assets_dest.join(path);

            if let Some(file) = entry.as_file() {
                // Create parent directories if needed
                if let Some(parent) = dest_path.parent() {
                    fs::create_dir_all(parent).map_err(|e| {
                        BuildonomyError::Io(format!(
                            "Failed to create directory {}: {e}",
                            parent.display()
                        ))
                    })?;
                }

                // Write file contents
                fs::write(&dest_path, file.contents()).map_err(|e| {
                    BuildonomyError::Io(format!(
                        "Failed to write asset {}: {e}",
                        dest_path.display()
                    ))
                })?;
            }
        }
    } else {
        // Extract everything (vendored mode)
        ASSETS
            .extract(&assets_dest)
            .map_err(|e| BuildonomyError::Io(format!("Failed to extract assets: {e}")))?;
    }

    // Extract WASM artifacts (only if compiled with bin feature)
    // WASM files are essential for interactive viewer functionality
    #[cfg(feature = "bin")]
    {
        let wasm_js_path = assets_dest.join("noet_core.js");
        let wasm_binary_path = assets_dest.join("noet_core_bg.wasm");

        std::fs::write(&wasm_js_path, WASM_JS_GLUE).map_err(|e| {
            BuildonomyError::Io(format!(
                "Failed to write WASM JS glue {}: {e}",
                wasm_js_path.display()
            ))
        })?;

        std::fs::write(&wasm_binary_path, WASM_BINARY).map_err(|e| {
            BuildonomyError::Io(format!(
                "Failed to write WASM binary {}: {e}",
                wasm_binary_path.display()
            ))
        })?;
    }

    Ok(())
}

/// Get stylesheet URLs for HTML generation
///
/// Returns appropriate URLs based on whether CDN or local assets should be used.
///
/// # Parameters
/// - `use_cdn`: If `true`, return CDN URLs for Open Props
///
/// # CDN Mode
/// - Open Props and Normalize: Loaded from unpkg.com CDN
/// - Custom CSS (themes, layout): Local paths (extracted from vendored assets)
///
/// # Local Mode
/// - All assets: Local relative paths under `assets/`
///
/// # Examples
///
/// ```rust
/// use noet_core::codec::assets;
///
/// // CDN mode
/// let urls = assets::get_stylesheet_urls(true);
/// assert!(urls.open_props.starts_with("https://"));
///
/// // Local mode
/// let urls = assets::get_stylesheet_urls(false);
/// assert!(urls.open_props.starts_with("assets/"));
/// ```
pub fn get_stylesheet_urls(use_cdn: bool) -> StylesheetUrls {
    if use_cdn {
        StylesheetUrls {
            open_props: "https://unpkg.com/open-props@1.7.23/open-props.min.css".to_string(),
            normalize: "https://unpkg.com/open-props@1.7.23/normalize.min.css".to_string(),
            theme_light: "assets/noet-theme-light.css".to_string(),
            theme_dark: "assets/noet-theme-dark.css".to_string(),
            layout: "assets/noet-layout.css".to_string(),
        }
    } else {
        StylesheetUrls {
            open_props: "assets/open-props/open-props.min.css".to_string(),
            normalize: "assets/open-props/normalize.min.css".to_string(),
            theme_light: "assets/noet-theme-light.css".to_string(),
            theme_dark: "assets/noet-theme-dark.css".to_string(),
            layout: "assets/noet-layout.css".to_string(),
        }
    }
}

/// Get HTML template by layout
///
/// Returns the embedded HTML template for the specified layout.
///
/// # Parameters
/// - `layout`: Layout variant to use
///
/// # Returns
/// - Template string with placeholders for substitution
///
/// # Examples
///
/// ```rust
/// use noet_core::codec::assets::{self, Layout};
///
/// // Get responsive template
/// let template = assets::get_template(Layout::Responsive);
/// assert!(template.contains("{{CONTENT}}"));
///
/// // Get simple template
/// let template = assets::get_template(Layout::Simple);
/// assert!(template.contains("<article>"));
/// ```
pub fn get_template(layout: Layout) -> &'static str {
    layout.template()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_stylesheet_urls_cdn() {
        let urls = get_stylesheet_urls(true);
        assert!(urls.open_props.starts_with("https://"));
        assert!(urls.normalize.starts_with("https://"));
        assert!(urls.theme_light.starts_with("assets/"));
        assert!(urls.theme_dark.starts_with("assets/"));
        assert!(urls.layout.starts_with("assets/"));
    }

    #[test]
    fn test_stylesheet_urls_local() {
        let urls = get_stylesheet_urls(false);
        assert!(urls.open_props.starts_with("assets/"));
        assert!(urls.normalize.starts_with("assets/"));
        assert!(urls.theme_light.starts_with("assets/"));
        assert!(urls.theme_dark.starts_with("assets/"));
        assert!(urls.layout.starts_with("assets/"));
    }

    #[test]
    fn test_extract_assets_all() {
        use std::fs;
        use tempfile::TempDir;

        let temp = TempDir::new().unwrap();
        let output_dir = temp.path();

        // Extract without CDN (all assets)
        extract_assets(output_dir, false).unwrap();

        // Verify assets were extracted
        assert!(output_dir.join("assets/noet-theme-light.css").exists());
        assert!(output_dir.join("assets/noet-theme-dark.css").exists());
        assert!(output_dir.join("assets/noet-layout.css").exists());
        assert!(output_dir
            .join("assets/open-props/open-props.min.css")
            .exists());
        assert!(output_dir
            .join("assets/open-props/normalize.min.css")
            .exists());
    }

    #[test]
    fn test_extract_assets_cdn_mode() {
        use std::fs;
        use tempfile::TempDir;

        let temp = TempDir::new().unwrap();
        let output_dir = temp.path();

        // Extract with CDN (skip open-props)
        extract_assets(output_dir, true).unwrap();

        // Verify custom CSS extracted but not open-props
        assert!(output_dir.join("assets/noet-theme-light.css").exists());
        assert!(output_dir.join("assets/noet-theme-dark.css").exists());
        assert!(output_dir.join("assets/noet-layout.css").exists());
        assert!(!output_dir.join("assets/open-props").exists());
    }

    #[test]
    fn test_extract_assets_idempotent() {
        use tempfile::TempDir;

        let temp = TempDir::new().unwrap();
        let output_dir = temp.path();

        // Extract twice - should not fail
        extract_assets(output_dir, false).unwrap();
        extract_assets(output_dir, false).unwrap();

        // Verify still works
        assert!(output_dir.join("assets/noet-theme-light.css").exists());
    }

    #[test]
    fn test_get_template_simple() {
        let template = get_template(Layout::Simple);
        assert!(template.contains("{{CONTENT}}"));
        assert!(template.contains("{{TITLE}}"));
        assert!(template.contains("{{METADATA}}"));
        assert!(template.contains("<article>"));
    }

    #[test]
    fn test_get_template_responsive() {
        let template = get_template(Layout::Responsive);
        assert!(template.contains("{{CONTENT}}"));
        assert!(template.contains("{{TITLE}}"));
        assert!(template.contains("{{METADATA}}"));
        assert!(template.contains("noet-container"));
        assert!(template.contains("noet-nav"));
        assert!(template.contains("noet-metadata"));
    }

    #[test]
    fn test_layout_from_str() {
        assert_eq!(Layout::from_str("simple").unwrap(), Layout::Simple);
        assert_eq!(Layout::from_str("responsive").unwrap(), Layout::Responsive);
        assert!(Layout::from_str("unknown").is_err());
    }

    #[test]
    fn test_layout_display() {
        assert_eq!(Layout::Simple.to_string(), "simple");
        assert_eq!(Layout::Responsive.to_string(), "responsive");
    }

    #[test]
    fn test_layout_default() {
        assert_eq!(Layout::default(), Layout::Simple);
    }

    #[test]
    fn test_template_placeholders() {
        for layout in &[Layout::Simple, Layout::Responsive] {
            let template = get_template(*layout);
            assert!(
                template.contains("{{CONTENT}}"),
                "Missing CONTENT placeholder in {}",
                layout
            );
            assert!(
                template.contains("{{TITLE}}"),
                "Missing TITLE placeholder in {}",
                layout
            );
            assert!(
                template.contains("{{METADATA}}"),
                "Missing METADATA placeholder in {}",
                layout
            );
        }
    }
}
