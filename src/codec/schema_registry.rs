// Auto-generated by compile_schema.py. Do not edit.

use crate::properties::WeightKind;
use toml::Value as TomlValue;

/// List of all known schema names that have graph field definitions.
/// Used by detect_schema_from_path to match path components.
pub const KNOWN_SCHEMAS: &[(&str, &str)] = &[
    ("intentions", "intention_lattice.intention"),
];

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum EdgeDirection {
    Upstream,
    Downstream,
}

pub struct GraphField {
    pub field_name: &'static str,
    pub direction: EdgeDirection,
    pub weight_kind: WeightKind,
    pub required: bool,
    pub payload_fields: Vec<&'static str>,  // Fields to extract into edge payload
}

pub struct SchemaDefinition {
    pub graph_fields: Vec<GraphField>,
}

pub fn get_schema_definition(schema_name: &str) -> Option<SchemaDefinition> {
    match schema_name {
        "intention_lattice.intention" => Some(SchemaDefinition {
            graph_fields: vec![
                GraphField {
                    field_name: "parent_connections",
                    direction: EdgeDirection::Downstream,
                    weight_kind: WeightKind::Pragmatic,
                    payload_fields: vec!["relationship_semantics", "motivation_kinds", "notes"],
                    required: false,
                },
            ],
        }),
        _ => None,
    }
}

/// Migrate old relationship_profile format to new relationship_semantics format
///
/// Converts:
/// - relationship_profile (object with numeric intensities) -> relationship_semantics (array)
/// - Removes computed types (tensions_with, trades_off, contextual)
/// - Applies threshold: intensity > 0.0 -> include semantic kind
/// - Converts to PascalCase enum values
pub fn migrate_relationship_profile(item: &mut TomlValue) -> bool {
    let mut migrated = false;
    
    // Check if this is a table with relationship_profile
    if let TomlValue::Table(table) = item {
        if let Some(TomlValue::Table(profile)) = table.get("relationship_profile") {
            let mut semantics = Vec::new();
            
            // Map any non-zero intensity to semantic kinds
            if let Some(TomlValue::Float(v)) = profile.get("constitutive") {
                if *v > 0.0 {
                    semantics.push(TomlValue::String("Constitutive".to_string()));
                }
            }
            if let Some(TomlValue::Float(v)) = profile.get("instrumental") {
                if *v > 0.0 {
                    semantics.push(TomlValue::String("Instrumental".to_string()));
                }
            }
            if let Some(TomlValue::Float(v)) = profile.get("expressive") {
                if *v > 0.0 {
                    semantics.push(TomlValue::String("Expressive".to_string()));
                }
            }
            if let Some(TomlValue::Float(v)) = profile.get("exploratory") {
                if *v > 0.0 {  // Include exploratory if present at all
                    semantics.push(TomlValue::String("Exploratory".to_string()));
                }
            }
            
            // Only migrate if we found semantic kinds
            if !semantics.is_empty() {
                table.insert("relationship_semantics".to_string(), TomlValue::Array(semantics));
                table.remove("relationship_profile");
                migrated = true;
            }
        }
    }
    
    migrated
}

/// Recursively migrate all items in an array field
pub fn migrate_array_field(array: &mut Vec<TomlValue>) -> bool {
    let mut migrated = false;
    for item in array.iter_mut() {
        if migrate_relationship_profile(item) {
            migrated = true;
        }
    }
    migrated
}

/// Apply schema-specific migrations to a document
///
/// This function is called during TOML parsing to automatically migrate
/// old schema formats to current versions.
pub fn migrate_schema(schema_name: &str, document: &mut TomlValue) -> bool {
    match schema_name {
        "intention_lattice.intention" => {
            let mut migrated = false;
            
            // Migrate parent_connections array
            if let TomlValue::Table(table) = document {
                if let Some(TomlValue::Array(connections)) = table.get_mut("parent_connections") {
                    if migrate_array_field(connections) {
                        migrated = true;
                    }
                }
            }
            
            migrated
        }
        _ => false,
    }
}